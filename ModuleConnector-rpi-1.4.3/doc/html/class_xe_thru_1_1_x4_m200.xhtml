<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModuleConnector: XeThru::X4M200 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">ModuleConnector
          &#160;<span id="projectnumber">1.4.3</span>
        </div>
        <div id="projectbrief" class="col-sm-12">Project brief</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_xe_thru.xhtml">XeThru</a></li><li class="navelem"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml">X4M200</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_xe_thru_1_1_x4_m200-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XeThru::X4M200 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface to the Xethru <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> Application module.  
 <a href="class_xe_thru_1_1_x4_m200.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_x4_m200_8hpp_source.xhtml">X4M200.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69a8c13fb828bbf27a3c24bcd82ee6ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a69a8c13fb828bbf27a3c24bcd82ee6ae">X4M200</a> (LockedRadarInterfacePtr &amp;radar_interface)</td></tr>
<tr class="memdesc:a69a8c13fb828bbf27a3c24bcd82ee6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a69a8c13fb828bbf27a3c24bcd82ee6ae">More...</a><br /></td></tr>
<tr class="separator:a69a8c13fb828bbf27a3c24bcd82ee6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6359bd91162372401c48b776f5df0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a1d6359bd91162372401c48b776f5df0c">~X4M200</a> ()</td></tr>
<tr class="memdesc:a1d6359bd91162372401c48b776f5df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a1d6359bd91162372401c48b776f5df0c">More...</a><br /></td></tr>
<tr class="separator:a1d6359bd91162372401c48b776f5df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41104e3d2da276d8a1062a172a96314f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a41104e3d2da276d8a1062a172a96314f">set_debug_level</a> (unsigned char level)</td></tr>
<tr class="memdesc:a41104e3d2da276d8a1062a172a96314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets debug level in the Xethru module.  <a href="#a41104e3d2da276d8a1062a172a96314f">More...</a><br /></td></tr>
<tr class="separator:a41104e3d2da276d8a1062a172a96314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c261955578f57a0a7ec90e358243d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a52c261955578f57a0a7ec90e358243d7">set_baudrate</a> (uint32_t baudrate)</td></tr>
<tr class="memdesc:a52c261955578f57a0a7ec90e358243d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set baudrate for serial communication during <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> operation.  <a href="#a52c261955578f57a0a7ec90e358243d7">More...</a><br /></td></tr>
<tr class="separator:a52c261955578f57a0a7ec90e358243d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bf194b6c4db57768425a02bea776ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#af8bf194b6c4db57768425a02bea776ce">ping</a> (uint32_t *pong_value)</td></tr>
<tr class="memdesc:af8bf194b6c4db57768425a02bea776ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure there is a connection to firmware on the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module.  <a href="#af8bf194b6c4db57768425a02bea776ce">More...</a><br /></td></tr>
<tr class="separator:af8bf194b6c4db57768425a02bea776ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e9a8c13407ca3d45b0b11dca08ba33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a15e9a8c13407ca3d45b0b11dca08ba33">get_system_info</a> (const uint8_t info_code, std::string *system_info)</td></tr>
<tr class="memdesc:a15e9a8c13407ca3d45b0b11dca08ba33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing system information given by infocode:<br />
  <a href="#a15e9a8c13407ca3d45b0b11dca08ba33">More...</a><br /></td></tr>
<tr class="separator:a15e9a8c13407ca3d45b0b11dca08ba33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c541b6aeac38360b6b8b7132f36f086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a4c541b6aeac38360b6b8b7132f36f086">reset</a> ()</td></tr>
<tr class="memdesc:a4c541b6aeac38360b6b8b7132f36f086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets and restart the module.  <a href="#a4c541b6aeac38360b6b8b7132f36f086">More...</a><br /></td></tr>
<tr class="separator:a4c541b6aeac38360b6b8b7132f36f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0e2fa9756ab51bb666d49abcbd7b5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6a0e2fa9756ab51bb666d49abcbd7b5f">module_reset</a> ()</td></tr>
<tr class="memdesc:a6a0e2fa9756ab51bb666d49abcbd7b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the module.  <a href="#a6a0e2fa9756ab51bb666d49abcbd7b5f">More...</a><br /></td></tr>
<tr class="separator:a6a0e2fa9756ab51bb666d49abcbd7b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7373c8d262cfbcaf1fd4bc5b81a8154f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a7373c8d262cfbcaf1fd4bc5b81a8154f">reset_to_factory_preset</a> ()</td></tr>
<tr class="memdesc:a7373c8d262cfbcaf1fd4bc5b81a8154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all parameters in the module to factory presets.  <a href="#a7373c8d262cfbcaf1fd4bc5b81a8154f">More...</a><br /></td></tr>
<tr class="separator:a7373c8d262cfbcaf1fd4bc5b81a8154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3c7d9d302abecd825a9fec8e08ec37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a1a3c7d9d302abecd825a9fec8e08ec37">start_bootloader</a> ()</td></tr>
<tr class="memdesc:a1a3c7d9d302abecd825a9fec8e08ec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters the bootloader for FW upgrades.  <a href="#a1a3c7d9d302abecd825a9fec8e08ec37">More...</a><br /></td></tr>
<tr class="separator:a1a3c7d9d302abecd825a9fec8e08ec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff968deb07f1ea55297a8934486fed24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aff968deb07f1ea55297a8934486fed24">system_run_test</a> (const uint8_t testcode, Bytes *data)</td></tr>
<tr class="memdesc:aff968deb07f1ea55297a8934486fed24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the different manufacturing tests identified by testcode.  <a href="#aff968deb07f1ea55297a8934486fed24">More...</a><br /></td></tr>
<tr class="separator:aff968deb07f1ea55297a8934486fed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed1474ea017d7ed85383d9ec10e23e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#af2ed1474ea017d7ed85383d9ec10e23e">load_profile</a> (const uint32_t profileid)</td></tr>
<tr class="memdesc:af2ed1474ea017d7ed85383d9ec10e23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the profile given by profileid.  <a href="#af2ed1474ea017d7ed85383d9ec10e23e">More...</a><br /></td></tr>
<tr class="separator:af2ed1474ea017d7ed85383d9ec10e23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd81c3e87636f21be43a49affed6266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2bd81c3e87636f21be43a49affed6266">set_sensor_mode</a> (const uint8_t mode, const uint8_t param)</td></tr>
<tr class="memdesc:a2bd81c3e87636f21be43a49affed6266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the execution mode of the sensor.  <a href="#a2bd81c3e87636f21be43a49affed6266">More...</a><br /></td></tr>
<tr class="separator:a2bd81c3e87636f21be43a49affed6266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8861f297daa6ec6c8ad2c0ee4be9027"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ab8861f297daa6ec6c8ad2c0ee4be9027">set_sensitivity</a> (const uint32_t sensitivity)</td></tr>
<tr class="memdesc:ab8861f297daa6ec6c8ad2c0ee4be9027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the overall sensitivity.  <a href="#ab8861f297daa6ec6c8ad2c0ee4be9027">More...</a><br /></td></tr>
<tr class="separator:ab8861f297daa6ec6c8ad2c0ee4be9027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6df5cb2557d5d12abbc36b92d154b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#abfd6df5cb2557d5d12abbc36b92d154b">set_detection_zone</a> (const float start, const float end)</td></tr>
<tr class="memdesc:abfd6df5cb2557d5d12abbc36b92d154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current detection zone.  <a href="#abfd6df5cb2557d5d12abbc36b92d154b">More...</a><br /></td></tr>
<tr class="separator:abfd6df5cb2557d5d12abbc36b92d154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fc10d80a5287c4ee8e272edcab0c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae1fc10d80a5287c4ee8e272edcab0c03">get_detection_zone</a> (float *start, float *end)</td></tr>
<tr class="memdesc:ae1fc10d80a5287c4ee8e272edcab0c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual detection zone.  <a href="#ae1fc10d80a5287c4ee8e272edcab0c03">More...</a><br /></td></tr>
<tr class="separator:ae1fc10d80a5287c4ee8e272edcab0c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2746a88eddd98977ba793fe684a5179"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aa2746a88eddd98977ba793fe684a5179">get_detection_zone_limits</a> (float *min, float *max, float *step)</td></tr>
<tr class="memdesc:aa2746a88eddd98977ba793fe684a5179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the potential settings of detection zone from the module.  <a href="#aa2746a88eddd98977ba793fe684a5179">More...</a><br /></td></tr>
<tr class="separator:aa2746a88eddd98977ba793fe684a5179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8be27b4da3f664053c9cd8e81e78e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aec8be27b4da3f664053c9cd8e81e78e8">set_led_control</a> (const uint8_t mode, uint8_t intensity)</td></tr>
<tr class="memdesc:aec8be27b4da3f664053c9cd8e81e78e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command configures the LED mode.  <a href="#aec8be27b4da3f664053c9cd8e81e78e8">More...</a><br /></td></tr>
<tr class="separator:aec8be27b4da3f664053c9cd8e81e78e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158ed65e4c61cd86bd3a7e52cb83eb52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a158ed65e4c61cd86bd3a7e52cb83eb52">set_output_control</a> (const uint32_t output_feature, const uint32_t output_control)</td></tr>
<tr class="memdesc:a158ed65e4c61cd86bd3a7e52cb83eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control module profile output.  <a href="#a158ed65e4c61cd86bd3a7e52cb83eb52">More...</a><br /></td></tr>
<tr class="separator:a158ed65e4c61cd86bd3a7e52cb83eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec1372397f563b5f6d3ce572e655d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ad0ec1372397f563b5f6d3ce572e655d6">peek_message_baseband_ap</a> ()</td></tr>
<tr class="memdesc:ad0ec1372397f563b5f6d3ce572e655d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> messages available in queue.  <a href="#ad0ec1372397f563b5f6d3ce572e655d6">More...</a><br /></td></tr>
<tr class="separator:ad0ec1372397f563b5f6d3ce572e655d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea029e840eac0c25d443e1f2cbcc689b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#aea029e840eac0c25d443e1f2cbcc689b">read_message_baseband_ap</a> (<a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml">BasebandApData</a> *baseband_ap)</td></tr>
<tr class="memdesc:aea029e840eac0c25d443e1f2cbcc689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> item from the queue.  <a href="#aea029e840eac0c25d443e1f2cbcc689b">More...</a><br /></td></tr>
<tr class="separator:aea029e840eac0c25d443e1f2cbcc689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90298563957a1b598a9d01125bb9a402"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a90298563957a1b598a9d01125bb9a402">peek_message_baseband_iq</a> ()</td></tr>
<tr class="memdesc:a90298563957a1b598a9d01125bb9a402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> messages available in queue.  <a href="#a90298563957a1b598a9d01125bb9a402">More...</a><br /></td></tr>
<tr class="separator:a90298563957a1b598a9d01125bb9a402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4754af20f03931ef68609d73fa9e01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ade4754af20f03931ef68609d73fa9e01">read_message_baseband_iq</a> (<a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml">BasebandIqData</a> *baseband_iq)</td></tr>
<tr class="memdesc:ade4754af20f03931ef68609d73fa9e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> item from the queue.  <a href="#ade4754af20f03931ef68609d73fa9e01">More...</a><br /></td></tr>
<tr class="separator:ade4754af20f03931ef68609d73fa9e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fedfdaed9ad94284f244a6318caf865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2fedfdaed9ad94284f244a6318caf865">peek_message_respiration_legacy</a> ()</td></tr>
<tr class="memdesc:a2fedfdaed9ad94284f244a6318caf865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of legacy respiration packets available in the queue.  <a href="#a2fedfdaed9ad94284f244a6318caf865">More...</a><br /></td></tr>
<tr class="separator:a2fedfdaed9ad94284f244a6318caf865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb07c1c7cfe12caef8a8c10f5fa5956e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#afb07c1c7cfe12caef8a8c10f5fa5956e">read_message_respiration_legacy</a> (<a class="el" href="class_xe_thru_1_1_respiration_data.xhtml">RespirationData</a> *respiration_data)</td></tr>
<tr class="memdesc:afb07c1c7cfe12caef8a8c10f5fa5956e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_respiration_data.xhtml" title="Represents the respiration status data coming from the module. ">RespirationData</a> item from the queue.  <a href="#afb07c1c7cfe12caef8a8c10f5fa5956e">More...</a><br /></td></tr>
<tr class="separator:afb07c1c7cfe12caef8a8c10f5fa5956e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7edec9ad6533ccd298d23dc86d8644e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#af7edec9ad6533ccd298d23dc86d8644e">peek_message_respiration_sleep</a> ()</td></tr>
<tr class="memdesc:af7edec9ad6533ccd298d23dc86d8644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration sleep packets available in the queue.  <a href="#af7edec9ad6533ccd298d23dc86d8644e">More...</a><br /></td></tr>
<tr class="separator:af7edec9ad6533ccd298d23dc86d8644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9946d8957f6c7cb01d3cedb8c1a341"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a9e9946d8957f6c7cb01d3cedb8c1a341">read_message_respiration_sleep</a> (<a class="el" href="class_xe_thru_1_1_sleep_data.xhtml">SleepData</a> *sleep_data)</td></tr>
<tr class="memdesc:a9e9946d8957f6c7cb01d3cedb8c1a341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one sleep data message from subscription queue.  <a href="#a9e9946d8957f6c7cb01d3cedb8c1a341">More...</a><br /></td></tr>
<tr class="separator:a9e9946d8957f6c7cb01d3cedb8c1a341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457b7e533407e35e84fb4eb82de7ced1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a457b7e533407e35e84fb4eb82de7ced1">peek_message_respiration_movinglist</a> ()</td></tr>
<tr class="memdesc:a457b7e533407e35e84fb4eb82de7ced1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration moving list packets available in the queue.  <a href="#a457b7e533407e35e84fb4eb82de7ced1">More...</a><br /></td></tr>
<tr class="separator:a457b7e533407e35e84fb4eb82de7ced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc62c8e24b43a53dda3a07b2d2f4383"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#afdc62c8e24b43a53dda3a07b2d2f4383">read_message_respiration_movinglist</a> (<a class="el" href="struct_xe_thru_1_1_respiration_moving_list_data.xhtml">RespirationMovingListData</a> *data)</td></tr>
<tr class="memdesc:afdc62c8e24b43a53dda3a07b2d2f4383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one respiration moving list data message from subscription queue.  <a href="#afdc62c8e24b43a53dda3a07b2d2f4383">More...</a><br /></td></tr>
<tr class="separator:afdc62c8e24b43a53dda3a07b2d2f4383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d47f686ccd59b200822404d9d3fd8dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a8d47f686ccd59b200822404d9d3fd8dc">peek_message_respiration_detectionlist</a> ()</td></tr>
<tr class="memdesc:a8d47f686ccd59b200822404d9d3fd8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of respiration detection list packets available in the queue.  <a href="#a8d47f686ccd59b200822404d9d3fd8dc">More...</a><br /></td></tr>
<tr class="separator:a8d47f686ccd59b200822404d9d3fd8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bb5cce20dedeac7c330d484d179b11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a72bb5cce20dedeac7c330d484d179b11">read_message_respiration_detectionlist</a> (<a class="el" href="struct_xe_thru_1_1_respiration_detection_list_data.xhtml">RespirationDetectionListData</a> *data)</td></tr>
<tr class="memdesc:a72bb5cce20dedeac7c330d484d179b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one respiration detection list data message from subscription queue.  <a href="#a72bb5cce20dedeac7c330d484d179b11">More...</a><br /></td></tr>
<tr class="separator:a72bb5cce20dedeac7c330d484d179b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6666cf88a6d0a86d790f51760cb74d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#afe6666cf88a6d0a86d790f51760cb74d">peek_message_pulsedoppler_float</a> ()</td></tr>
<tr class="memdesc:afe6666cf88a6d0a86d790f51760cb74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of pulse-Doppler float packets available in the queue.  <a href="#afe6666cf88a6d0a86d790f51760cb74d">More...</a><br /></td></tr>
<tr class="separator:afe6666cf88a6d0a86d790f51760cb74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a96f5482d9df531f402c74ff2d51e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ab4a96f5482d9df531f402c74ff2d51e0">read_message_pulsedoppler_float</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *data)</td></tr>
<tr class="memdesc:ab4a96f5482d9df531f402c74ff2d51e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one pulse-Doppler float data message from subscription queue.  <a href="#ab4a96f5482d9df531f402c74ff2d51e0">More...</a><br /></td></tr>
<tr class="separator:ab4a96f5482d9df531f402c74ff2d51e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e0e81941cfabaca4b92b2c6893ffee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ad6e0e81941cfabaca4b92b2c6893ffee">peek_message_pulsedoppler_byte</a> ()</td></tr>
<tr class="memdesc:ad6e0e81941cfabaca4b92b2c6893ffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of pulse-Doppler byte packets available in the queue.  <a href="#ad6e0e81941cfabaca4b92b2c6893ffee">More...</a><br /></td></tr>
<tr class="separator:ad6e0e81941cfabaca4b92b2c6893ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8e665b5296d5d99ba84b2017f57476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a2c8e665b5296d5d99ba84b2017f57476">read_message_pulsedoppler_byte</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *data)</td></tr>
<tr class="memdesc:a2c8e665b5296d5d99ba84b2017f57476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one pulse-Doppler byte data message from subscription queue.  <a href="#a2c8e665b5296d5d99ba84b2017f57476">More...</a><br /></td></tr>
<tr class="separator:a2c8e665b5296d5d99ba84b2017f57476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2fe65eb4686e53fbbaa2dad37e09a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#abb2fe65eb4686e53fbbaa2dad37e09a6">peek_message_noisemap_float</a> ()</td></tr>
<tr class="memdesc:abb2fe65eb4686e53fbbaa2dad37e09a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of noisemap float packets available in the queue.  <a href="#abb2fe65eb4686e53fbbaa2dad37e09a6">More...</a><br /></td></tr>
<tr class="separator:abb2fe65eb4686e53fbbaa2dad37e09a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79edd2912d46d2aa2112e78c803484f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a79edd2912d46d2aa2112e78c803484f4">read_message_noisemap_float</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *data)</td></tr>
<tr class="memdesc:a79edd2912d46d2aa2112e78c803484f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one noisemap float data message from subscription queue.  <a href="#a79edd2912d46d2aa2112e78c803484f4">More...</a><br /></td></tr>
<tr class="separator:a79edd2912d46d2aa2112e78c803484f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c2c60d44cb22001af967c2e04ea0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae73c2c60d44cb22001af967c2e04ea0b">peek_message_noisemap_byte</a> ()</td></tr>
<tr class="memdesc:ae73c2c60d44cb22001af967c2e04ea0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of noisemap byte packets available in the queue.  <a href="#ae73c2c60d44cb22001af967c2e04ea0b">More...</a><br /></td></tr>
<tr class="separator:ae73c2c60d44cb22001af967c2e04ea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33180f9c33edb66f1a60d0739a05840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac33180f9c33edb66f1a60d0739a05840">read_message_noisemap_byte</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *data)</td></tr>
<tr class="memdesc:ac33180f9c33edb66f1a60d0739a05840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one noisemap byte data message from subscription queue.  <a href="#ac33180f9c33edb66f1a60d0739a05840">More...</a><br /></td></tr>
<tr class="separator:ac33180f9c33edb66f1a60d0739a05840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225c7305fc8f4cd52bb6792d770cfa9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a225c7305fc8f4cd52bb6792d770cfa9c">load_noisemap</a> ()</td></tr>
<tr class="memdesc:a225c7305fc8f4cd52bb6792d770cfa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to load a previously stored noisemap.  <a href="#a225c7305fc8f4cd52bb6792d770cfa9c">More...</a><br /></td></tr>
<tr class="separator:a225c7305fc8f4cd52bb6792d770cfa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8d6cb2f2e1e21f04b58f210882415c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#adc8d6cb2f2e1e21f04b58f210882415c">store_noisemap</a> ()</td></tr>
<tr class="memdesc:adc8d6cb2f2e1e21f04b58f210882415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to store the current noisemap to module flash.  <a href="#adc8d6cb2f2e1e21f04b58f210882415c">More...</a><br /></td></tr>
<tr class="separator:adc8d6cb2f2e1e21f04b58f210882415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484cd54798070a8c96fdad5b8b6a68c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a484cd54798070a8c96fdad5b8b6a68c3">set_noisemap_control</a> (uint32_t noisemap_control)</td></tr>
<tr class="memdesc:a484cd54798070a8c96fdad5b8b6a68c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the use of noisemap.  <a href="#a484cd54798070a8c96fdad5b8b6a68c3">More...</a><br /></td></tr>
<tr class="separator:a484cd54798070a8c96fdad5b8b6a68c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b86d5bc9dd43fd35f9a6ff168172f89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6b86d5bc9dd43fd35f9a6ff168172f89">get_noisemap_control</a> (uint32_t *noisemap_control)</td></tr>
<tr class="memdesc:a6b86d5bc9dd43fd35f9a6ff168172f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current noisemap configuration.  <a href="#a6b86d5bc9dd43fd35f9a6ff168172f89">More...</a><br /></td></tr>
<tr class="separator:a6b86d5bc9dd43fd35f9a6ff168172f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64f643a66f18687552691263a705ce0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ac64f643a66f18687552691263a705ce0">get_parameter_file</a> (const std::string &amp;filename, std::string *const data)</td></tr>
<tr class="memdesc:ac64f643a66f18687552691263a705ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the complete parameter file from the module.  <a href="#ac64f643a66f18687552691263a705ce0">More...</a><br /></td></tr>
<tr class="separator:ac64f643a66f18687552691263a705ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75430041f9eea93f587ffc0e1800ec6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a75430041f9eea93f587ffc0e1800ec6d">get_profileid</a> (uint32_t *result)</td></tr>
<tr class="memdesc:a75430041f9eea93f587ffc0e1800ec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the currently loaded profile.  <a href="#a75430041f9eea93f587ffc0e1800ec6d">More...</a><br /></td></tr>
<tr class="separator:a75430041f9eea93f587ffc0e1800ec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a37be0e31a9151ca98636f5006338"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#ae56a37be0e31a9151ca98636f5006338">set_parameter_file</a> (const std::string *filename, const std::string *data)</td></tr>
<tr class="memdesc:ae56a37be0e31a9151ca98636f5006338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a named parameter file on target.  <a href="#ae56a37be0e31a9151ca98636f5006338">More...</a><br /></td></tr>
<tr class="separator:ae56a37be0e31a9151ca98636f5006338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface to the Xethru <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> Application module. </p>
<p>This interface is used to control the <a class="el" href="namespace_xe_thru.xhtml">XeThru</a> <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> module. See the data sheet of the <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> module for more information on the <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a69a8c13fb828bbf27a3c24bcd82ee6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a8c13fb828bbf27a3c24bcd82ee6ae">&sect;&nbsp;</a></span>X4M200()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::X4M200::X4M200 </td>
          <td>(</td>
          <td class="paramtype">LockedRadarInterfacePtr &amp;&#160;</td>
          <td class="paramname"><em>radar_interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radar_interface</td><td>internal object used to interface the radar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d6359bd91162372401c48b776f5df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6359bd91162372401c48b776f5df0c">&sect;&nbsp;</a></span>~X4M200()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::X4M200::~X4M200 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1fc10d80a5287c4ee8e272edcab0c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fc10d80a5287c4ee8e272edcab0c03">&sect;&nbsp;</a></span>get_detection_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_detection_zone </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual detection zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">start</td><td>start of detection zone in meters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>end of detection zone in meters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aa2746a88eddd98977ba793fe684a5179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2746a88eddd98977ba793fe684a5179">&sect;&nbsp;</a></span>get_detection_zone_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_detection_zone_limits </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the potential settings of detection zone from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>smallest value for detection zone start </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>largest value for detection zone end </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>detection zone start and end step size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a6b86d5bc9dd43fd35f9a6ff168172f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b86d5bc9dd43fd35f9a6ff168172f89">&sect;&nbsp;</a></span>get_noisemap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_noisemap_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>noisemap_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current noisemap configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">noisemap_control</td><td>A bitfield of the various features. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac64f643a66f18687552691263a705ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64f643a66f18687552691263a705ce0">&sect;&nbsp;</a></span>get_parameter_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_parameter_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the complete parameter file from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to a string containing the complete paramter file data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a75430041f9eea93f587ffc0e1800ec6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75430041f9eea93f587ffc0e1800ec6d">&sect;&nbsp;</a></span>get_profileid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_profileid </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of the currently loaded profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to the resulting profile_id. 0 in case of no profile loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a15e9a8c13407ca3d45b0b11dca08ba33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e9a8c13407ca3d45b0b11dca08ba33">&sect;&nbsp;</a></span>get_system_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::get_system_info </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>info_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>system_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing system information given by infocode:<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info_code</td><td>what information to query. Possible values are?<br />
 XTID_SSIC_ITEMNUMBER -&gt; Returns the product Item Number, including revision. This is programmed in Flash during manufacturing<br />
 XTID_SSIC_ORDERCODE -&gt; Returns the product order code<br />
 XTID_SSIC_FIRMWAREID -&gt; Returns the installed Firmware ID. As viewed from the "highest" level of the software, "X4M200"<br />
 XTID_SSIC_VERSION -&gt; Returns the installed Firmware Version. As viewed from the "highest" level of the software<br />
 XTID_SSIC_BUILD -&gt; Returns information of the SW Build installed on the device<br />
 XTID_SSIC_SERIALNUMBER -&gt; Returns the product serial number<br />
 XTID_SSIC_VERSIONLIST -&gt;Returns ID and version of all components. Calls all components and compound a string E.g. "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a225c7305fc8f4cd52bb6792d770cfa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225c7305fc8f4cd52bb6792d770cfa9c">&sect;&nbsp;</a></span>load_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::load_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to load a previously stored noisemap. </p>
<p>Not yet functional as of FW 1.3</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="af2ed1474ea017d7ed85383d9ec10e23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ed1474ea017d7ed85383d9ec10e23e">&sect;&nbsp;</a></span>load_profile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::load_profile </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>profileid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the profile given by profileid. </p>
<p>If another profile is already loaded, the other profile is unloaded before the new profile is loaded. The profile does not start, the module remains idle. <br />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">profileid</td><td>the id of the profile to load profileid = XTS_ID_APP_RESPIRATION_2 (xtid.h) : sleep profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a6a0e2fa9756ab51bb666d49abcbd7b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0e2fa9756ab51bb666d49abcbd7b5f">&sect;&nbsp;</a></span>module_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::module_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the module. </p>
<p>The client must perform a close and then an open on the <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> to reeastablish connection.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ad0ec1372397f563b5f6d3ce572e655d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ec1372397f563b5f6d3ce572e655d6">&sect;&nbsp;</a></span>peek_message_baseband_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_baseband_ap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="a90298563957a1b598a9d01125bb9a402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90298563957a1b598a9d01125bb9a402">&sect;&nbsp;</a></span>peek_message_baseband_iq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_baseband_iq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="ae73c2c60d44cb22001af967c2e04ea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73c2c60d44cb22001af967c2e04ea0b">&sect;&nbsp;</a></span>peek_message_noisemap_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_noisemap_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of noisemap byte packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="abb2fe65eb4686e53fbbaa2dad37e09a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2fe65eb4686e53fbbaa2dad37e09a6">&sect;&nbsp;</a></span>peek_message_noisemap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_noisemap_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of noisemap float packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="ad6e0e81941cfabaca4b92b2c6893ffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e0e81941cfabaca4b92b2c6893ffee">&sect;&nbsp;</a></span>peek_message_pulsedoppler_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_pulsedoppler_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of pulse-Doppler byte packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="afe6666cf88a6d0a86d790f51760cb74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6666cf88a6d0a86d790f51760cb74d">&sect;&nbsp;</a></span>peek_message_pulsedoppler_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_pulsedoppler_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of pulse-Doppler float packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a8d47f686ccd59b200822404d9d3fd8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d47f686ccd59b200822404d9d3fd8dc">&sect;&nbsp;</a></span>peek_message_respiration_detectionlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_detectionlist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration detection list packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a2fedfdaed9ad94284f244a6318caf865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fedfdaed9ad94284f244a6318caf865">&sect;&nbsp;</a></span>peek_message_respiration_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_legacy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of legacy respiration packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="a457b7e533407e35e84fb4eb82de7ced1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457b7e533407e35e84fb4eb82de7ced1">&sect;&nbsp;</a></span>peek_message_respiration_movinglist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_movinglist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration moving list packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="af7edec9ad6533ccd298d23dc86d8644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7edec9ad6533ccd298d23dc86d8644e">&sect;&nbsp;</a></span>peek_message_respiration_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::peek_message_respiration_sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of respiration sleep packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="af8bf194b6c4db57768425a02bea776ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bf194b6c4db57768425a02bea776ce">&sect;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::ping </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pong_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure there is a connection to firmware on the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pong</td><td>value: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aea029e840eac0c25d443e1f2cbcc689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea029e840eac0c25d443e1f2cbcc689b">&sect;&nbsp;</a></span>read_message_baseband_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_baseband_ap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml">BasebandApData</a> *&#160;</td>
          <td class="paramname"><em>baseband_ap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseband_ap</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ade4754af20f03931ef68609d73fa9e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4754af20f03931ef68609d73fa9e01">&sect;&nbsp;</a></span>read_message_baseband_iq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_baseband_iq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml">BasebandIqData</a> *&#160;</td>
          <td class="paramname"><em>baseband_iq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseband_iq</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac33180f9c33edb66f1a60d0739a05840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33180f9c33edb66f1a60d0739a05840">&sect;&nbsp;</a></span>read_message_noisemap_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_noisemap_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one noisemap byte data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting noisemap byte data </dd></dl>

</div>
</div>
<a id="a79edd2912d46d2aa2112e78c803484f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79edd2912d46d2aa2112e78c803484f4">&sect;&nbsp;</a></span>read_message_noisemap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_noisemap_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one noisemap float data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting noisemap float data </dd></dl>

</div>
</div>
<a id="a2c8e665b5296d5d99ba84b2017f57476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8e665b5296d5d99ba84b2017f57476">&sect;&nbsp;</a></span>read_message_pulsedoppler_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_pulsedoppler_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one pulse-Doppler byte data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting pulse-Doppler byte data </dd></dl>

</div>
</div>
<a id="ab4a96f5482d9df531f402c74ff2d51e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a96f5482d9df531f402c74ff2d51e0">&sect;&nbsp;</a></span>read_message_pulsedoppler_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_pulsedoppler_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one pulse-Doppler float data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting pulse-Doppler float data </dd></dl>

</div>
</div>
<a id="a72bb5cce20dedeac7c330d484d179b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bb5cce20dedeac7c330d484d179b11">&sect;&nbsp;</a></span>read_message_respiration_detectionlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_detectionlist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xe_thru_1_1_respiration_detection_list_data.xhtml">RespirationDetectionListData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one respiration detection list data message from subscription queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>A data object holding the resulting respiration detection listdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="afb07c1c7cfe12caef8a8c10f5fa5956e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb07c1c7cfe12caef8a8c10f5fa5956e">&sect;&nbsp;</a></span>read_message_respiration_legacy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_legacy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_respiration_data.xhtml">RespirationData</a> *&#160;</td>
          <td class="paramname"><em>respiration_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_respiration_data.xhtml" title="Represents the respiration status data coming from the module. ">RespirationData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">respiration_data</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_respiration_data.xhtml" title="Represents the respiration status data coming from the module. ">RespirationData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="afdc62c8e24b43a53dda3a07b2d2f4383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc62c8e24b43a53dda3a07b2d2f4383">&sect;&nbsp;</a></span>read_message_respiration_movinglist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_movinglist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xe_thru_1_1_respiration_moving_list_data.xhtml">RespirationMovingListData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one respiration moving list data message from subscription queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>A data object holding the resulting respiration moving listdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a9e9946d8957f6c7cb01d3cedb8c1a341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9946d8957f6c7cb01d3cedb8c1a341">&sect;&nbsp;</a></span>read_message_respiration_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::read_message_respiration_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_sleep_data.xhtml">SleepData</a> *&#160;</td>
          <td class="paramname"><em>sleep_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one sleep data message from subscription queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sleep_data</td><td>A data object holding the resulting respiration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a4c541b6aeac38360b6b8b7132f36f086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c541b6aeac38360b6b8b7132f36f086">&sect;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets and restart the module. </p>
<p>This is a convenience method that calls <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml#a6a0e2fa9756ab51bb666d49abcbd7b5f" title="Resets the module. ">module_reset()</a>, disconnects the communication port, and then reestablishes connection with the module.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a7373c8d262cfbcaf1fd4bc5b81a8154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7373c8d262cfbcaf1fd4bc5b81a8154f">&sect;&nbsp;</a></span>reset_to_factory_preset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::reset_to_factory_preset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all parameters in the module to factory presets. </p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a52c261955578f57a0a7ec90e358243d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c261955578f57a0a7ec90e358243d7">&sect;&nbsp;</a></span>set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set baudrate for serial communication during <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>enum representing the baudrate, XTID_BAUDRATE_XXX in xtid.h. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a41104e3d2da276d8a1062a172a96314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41104e3d2da276d8a1062a172a96314f">&sect;&nbsp;</a></span>set_debug_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_debug_level </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets debug level in the Xethru module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>New debug level. Valid range [0-9]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="abfd6df5cb2557d5d12abbc36b92d154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6df5cb2557d5d12abbc36b92d154b">&sect;&nbsp;</a></span>set_detection_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_detection_zone </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current detection zone. </p>
<p>Rules: See <a class="el" href="class_xe_thru_1_1_x4_m200.xhtml" title="Interface to the Xethru X4M200 Application module. ">X4M200</a> datasheet. The actual detection zone is determined by profile configuration. Use the get_detection_zone command to get the actual values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start of detection zone in meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end of detection zone in meters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aec8be27b4da3f664053c9cd8e81e78e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8be27b4da3f664053c9cd8e81e78e8">&sect;&nbsp;</a></span>set_led_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_led_control </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command configures the LED mode. </p>
<p><br />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>(modes are defined in xtid.h) <br />
 mode = XTID_LED_MODE_OFF : OFF <br />
 mode = XTID_LED_MODE_SIMPLE : simple <br />
 mode = XTID_LED_MODE_FULL : full (default) <br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intensity</td><td>0 to 100, 0=low, 100=high, not implemented yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a484cd54798070a8c96fdad5b8b6a68c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484cd54798070a8c96fdad5b8b6a68c3">&sect;&nbsp;</a></span>set_noisemap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_noisemap_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noisemap_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the use of noisemap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noisemap_control</td><td>A bitfield of the various features. <br />
 XTID_NOISEMAP_CONTROL_ENABLE -&gt; Bit 0, turn on use of noisemap.<br />
 XTID_NOISEMAP_CONTROL_ADAPTIVE -&gt; Bit 1, adapt noisemap over time.<br />
 XTID_NOISEMAP_CONTROL_INIT_ON_RESET -&gt; Bit 2, don't store but initialize the noisemap every time. Bit 2 unset means load the stored noisemap if present, and initialize and store it if not present.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a158ed65e4c61cd86bd3a7e52cb83eb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158ed65e4c61cd86bd3a7e52cb83eb52">&sect;&nbsp;</a></span>set_output_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_output_control </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control module profile output. </p>
<p>Enable and disable data messages. Several calls can be made, one for each available output message the profile provides.</p>
<p>Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be enabled at a time. Enabling one disables the other. Disabling one, even if it is already disabled, disables the other.</p>
<p>Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte output, and vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_feature</td><td>see values in xtid.h.<br />
 Possible features are:<br />
 XTS_ID_RESPIRATION_MOVINGLIST<br />
 XTS_ID_RESPIRATION_DETECTIONLIST<br />
 XTS_ID_RESP_STATUS<br />
 XTS_ID_RESP_STATUS_EXT<br />
 XTS_ID_BASEBAND_IQ<br />
 XTS_ID_BASEBAND_AMPLITUDE_PHASE<br />
 XTS_ID_PULSEDOPPLER_FLOAT<br />
 XTS_ID_PULSEDOPPLER_BYTE<br />
 XTS_ID_NOISEMAP_FLOAT<br />
 XTS_ID_NOISEMAP_BYTE<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_control</td><td>see values in xtid.h<br />
 Typical values:<br />
 XTID_OUTPUT_CONTROL_DISABLE = disable<br />
 XTID_OUTPUT_CONTROL_ENABLE = enable<br />
 <br />
 For pulse-Doppler and noisemap byte/float:<br />
 XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE<br />
 XTID_OUTPUT_CONTROL_PD_FAST_ENABLE<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ae56a37be0e31a9151ca98636f5006338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a37be0e31a9151ca98636f5006338">&sect;&nbsp;</a></span>set_parameter_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_parameter_file </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a named parameter file on target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name to call the parameter file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The content of the parameter-file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ab8861f297daa6ec6c8ad2c0ee4be9027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8861f297daa6ec6c8ad2c0ee4be9027">&sect;&nbsp;</a></span>set_sensitivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_sensitivity </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sensitivity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the overall sensitivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sensitivity</td><td>: 0 to 9, 0 = low, 9 = high </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a2bd81c3e87636f21be43a49affed6266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd81c3e87636f21be43a49affed6266">&sect;&nbsp;</a></span>set_sensor_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::set_sensor_mode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the execution mode of the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>see xtid.h for profileid values.<br />
 XTID_SM_RUN : Start profile execution<br />
 XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to Run.<br />
 XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.<br />
 XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to profile execution. Can then interact directly with <a class="el" href="class_xe_thru_1_1_x_e_p.xhtml" title="XEP class gives access to XEP functionality on target via module connector. ">XEP</a> / X4Driver. Will disrupt profile performance.<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Not used, ignored, can be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a1a3c7d9d302abecd825a9fec8e08ec37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3c7d9d302abecd825a9fec8e08ec37">&sect;&nbsp;</a></span>start_bootloader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::start_bootloader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters the bootloader for FW upgrades. </p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="adc8d6cb2f2e1e21f04b58f210882415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8d6cb2f2e1e21f04b58f210882415c">&sect;&nbsp;</a></span>store_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::store_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to store the current noisemap to module flash. </p>
<p>Fails if a store already is active, for example during the first initialize with XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aff968deb07f1ea55297a8934486fed24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff968deb07f1ea55297a8934486fed24">&sect;&nbsp;</a></span>system_run_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M200::system_run_test </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>testcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the different manufacturing tests identified by testcode. </p>
<p>Can return any number of results depending on test_mode. Host must know how to parse test results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">testcode</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data buffer containing the result from a test run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_x4_m200_8hpp_source.xhtml">X4M200.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
