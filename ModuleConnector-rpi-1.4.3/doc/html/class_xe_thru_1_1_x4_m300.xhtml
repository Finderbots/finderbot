<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModuleConnector: XeThru::X4M300 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- Platform title -->
    <div class="page-title-bar container-fluid">
      <div id="projectalign" class="row">
        <div id="projectname" class="col-sm-12">ModuleConnector
          &#160;<span id="projectnumber">1.4.3</span>
        </div>
        <div id="projectbrief" class="col-sm-12">Project brief</div>
      </div>
    </div>
    <div class="topbar">
      <div class="container">
        <div id="titlearea">
          <div class="xethru-logo">
            <img src="xethru-logo_220x55HD.png" alt="Novelda XeThru web site" id="logo-image" />
          </div>
        </div>
        <!-- end header part -->
        <!-- Generated by Doxygen 1.8.12 -->
        <!--BEGIN MAIN-NAV AND SEARCHENGINE-->
        <div id="main-nav"></div>
        <!--END MAIN-NAV AND SEARCHENGINE-->
      </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_xe_thru.xhtml">XeThru</a></li><li class="navelem"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml">X4M300</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_xe_thru_1_1_x4_m300-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XeThru::X4M300 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface to the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> Application module.  
 <a href="class_xe_thru_1_1_x4_m300.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_x4_m300_8hpp_source.xhtml">X4M300.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af2abdd59addf413ce3fdb565a490779a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#af2abdd59addf413ce3fdb565a490779a">X4M300</a> (LockedRadarInterfacePtr &amp;radar_interface)</td></tr>
<tr class="separator:af2abdd59addf413ce3fdb565a490779a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec679d496f341bafdb5458fde8902e2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#aec679d496f341bafdb5458fde8902e2e">~X4M300</a> ()</td></tr>
<tr class="separator:aec679d496f341bafdb5458fde8902e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ad0d3a96aa7c2bfb3e30c9b40de3bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a87ad0d3a96aa7c2bfb3e30c9b40de3bb">set_debug_level</a> (unsigned char level)</td></tr>
<tr class="memdesc:a87ad0d3a96aa7c2bfb3e30c9b40de3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets debug level in the Xethru module.  <a href="#a87ad0d3a96aa7c2bfb3e30c9b40de3bb">More...</a><br /></td></tr>
<tr class="separator:a87ad0d3a96aa7c2bfb3e30c9b40de3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2645687c0047f3548f754d2b93e94e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a2645687c0047f3548f754d2b93e94e32">set_baudrate</a> (uint32_t baudrate)</td></tr>
<tr class="memdesc:a2645687c0047f3548f754d2b93e94e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set baudrate for serial communication during <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> operation.  <a href="#a2645687c0047f3548f754d2b93e94e32">More...</a><br /></td></tr>
<tr class="separator:a2645687c0047f3548f754d2b93e94e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac344832954bf56cbc5420ba08fb0514f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ac344832954bf56cbc5420ba08fb0514f">ping</a> (uint32_t *pong_value)</td></tr>
<tr class="memdesc:ac344832954bf56cbc5420ba08fb0514f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure there is a connection to firmware on the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module.  <a href="#ac344832954bf56cbc5420ba08fb0514f">More...</a><br /></td></tr>
<tr class="separator:ac344832954bf56cbc5420ba08fb0514f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d48a8a575e606e1396973cdba3aa006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a9d48a8a575e606e1396973cdba3aa006">get_system_info</a> (const uint8_t info_code, std::string *system_info)</td></tr>
<tr class="memdesc:a9d48a8a575e606e1396973cdba3aa006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing system information given by infocode:<br />
  <a href="#a9d48a8a575e606e1396973cdba3aa006">More...</a><br /></td></tr>
<tr class="separator:a9d48a8a575e606e1396973cdba3aa006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6020a93451876f33aa81fe6a38f1d078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a6020a93451876f33aa81fe6a38f1d078">reset</a> ()</td></tr>
<tr class="memdesc:a6020a93451876f33aa81fe6a38f1d078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets and restarts the module.  <a href="#a6020a93451876f33aa81fe6a38f1d078">More...</a><br /></td></tr>
<tr class="separator:a6020a93451876f33aa81fe6a38f1d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe225acfe8173ac55393401dfccfe2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a9fe225acfe8173ac55393401dfccfe2e">module_reset</a> ()</td></tr>
<tr class="memdesc:a9fe225acfe8173ac55393401dfccfe2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the module.  <a href="#a9fe225acfe8173ac55393401dfccfe2e">More...</a><br /></td></tr>
<tr class="separator:a9fe225acfe8173ac55393401dfccfe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b48c4a8bf8db715de9f72de65520159"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a3b48c4a8bf8db715de9f72de65520159">reset_to_factory_preset</a> ()</td></tr>
<tr class="memdesc:a3b48c4a8bf8db715de9f72de65520159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all parameters in the module to factory presets.  <a href="#a3b48c4a8bf8db715de9f72de65520159">More...</a><br /></td></tr>
<tr class="separator:a3b48c4a8bf8db715de9f72de65520159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d0ed6b1e9227a30091554859dd8fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#af92d0ed6b1e9227a30091554859dd8fa">start_bootloader</a> ()</td></tr>
<tr class="memdesc:af92d0ed6b1e9227a30091554859dd8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters the bootloader for FW upgrades.  <a href="#af92d0ed6b1e9227a30091554859dd8fa">More...</a><br /></td></tr>
<tr class="separator:af92d0ed6b1e9227a30091554859dd8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467f849f6541ec51720e35e944d255ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a467f849f6541ec51720e35e944d255ae">system_run_test</a> (const uint8_t testcode, Bytes *data)</td></tr>
<tr class="memdesc:a467f849f6541ec51720e35e944d255ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the different manufacturing tests identified by testcode.  <a href="#a467f849f6541ec51720e35e944d255ae">More...</a><br /></td></tr>
<tr class="separator:a467f849f6541ec51720e35e944d255ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace86c93e998280f19ae64cbd05801d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#aace86c93e998280f19ae64cbd05801d5">load_profile</a> (const uint32_t profileid)</td></tr>
<tr class="memdesc:aace86c93e998280f19ae64cbd05801d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the profile given by profileid.  <a href="#aace86c93e998280f19ae64cbd05801d5">More...</a><br /></td></tr>
<tr class="separator:aace86c93e998280f19ae64cbd05801d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ab01887a1144ffc88b47d344bbbf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a566ab01887a1144ffc88b47d344bbbf5">set_sensor_mode</a> (const uint8_t mode, const uint8_t param)</td></tr>
<tr class="memdesc:a566ab01887a1144ffc88b47d344bbbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the execution mode of the sensor.  <a href="#a566ab01887a1144ffc88b47d344bbbf5">More...</a><br /></td></tr>
<tr class="separator:a566ab01887a1144ffc88b47d344bbbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab6f73f1e935aee36eda94c46972d37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a2ab6f73f1e935aee36eda94c46972d37">set_sensitivity</a> (const uint32_t sensitivity)</td></tr>
<tr class="memdesc:a2ab6f73f1e935aee36eda94c46972d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the overall sensitivity.  <a href="#a2ab6f73f1e935aee36eda94c46972d37">More...</a><br /></td></tr>
<tr class="separator:a2ab6f73f1e935aee36eda94c46972d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018a43834fb990f9a6205c69ee095555"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a018a43834fb990f9a6205c69ee095555">set_detection_zone</a> (const float start, const float end)</td></tr>
<tr class="memdesc:a018a43834fb990f9a6205c69ee095555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current detection zone.  <a href="#a018a43834fb990f9a6205c69ee095555">More...</a><br /></td></tr>
<tr class="separator:a018a43834fb990f9a6205c69ee095555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08372898089ecd75af3ee98e9fdc6f55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a08372898089ecd75af3ee98e9fdc6f55">get_detection_zone</a> (float *start, float *end)</td></tr>
<tr class="memdesc:a08372898089ecd75af3ee98e9fdc6f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual detection zone.  <a href="#a08372898089ecd75af3ee98e9fdc6f55">More...</a><br /></td></tr>
<tr class="separator:a08372898089ecd75af3ee98e9fdc6f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97f57cf02e81c406942aedc033e634"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a1e97f57cf02e81c406942aedc033e634">get_detection_zone_limits</a> (float *min, float *max, float *step)</td></tr>
<tr class="memdesc:a1e97f57cf02e81c406942aedc033e634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the potential settings of detection zone from the module.  <a href="#a1e97f57cf02e81c406942aedc033e634">More...</a><br /></td></tr>
<tr class="separator:a1e97f57cf02e81c406942aedc033e634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ce5eb83d2f4d758a52ed3deae80e4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a51ce5eb83d2f4d758a52ed3deae80e4c">set_led_control</a> (const uint8_t mode, uint8_t intensity)</td></tr>
<tr class="memdesc:a51ce5eb83d2f4d758a52ed3deae80e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command configures the LED mode.  <a href="#a51ce5eb83d2f4d758a52ed3deae80e4c">More...</a><br /></td></tr>
<tr class="separator:a51ce5eb83d2f4d758a52ed3deae80e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e832113822e712facfb6a9bd9c9482"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a62e832113822e712facfb6a9bd9c9482">set_output_control</a> (const uint32_t output_feature, const uint32_t output_control)</td></tr>
<tr class="memdesc:a62e832113822e712facfb6a9bd9c9482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control module profile output.  <a href="#a62e832113822e712facfb6a9bd9c9482">More...</a><br /></td></tr>
<tr class="separator:a62e832113822e712facfb6a9bd9c9482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260f7f37b04d3687cd42a3670fa4206b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a260f7f37b04d3687cd42a3670fa4206b">peek_message_presence_single</a> ()</td></tr>
<tr class="memdesc:a260f7f37b04d3687cd42a3670fa4206b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml" title="Encapsulates and aggregates true presenece data coming from the Xethru X4M300 module. ">PresenceSingleData</a> messages available in queue.  <a href="#a260f7f37b04d3687cd42a3670fa4206b">More...</a><br /></td></tr>
<tr class="separator:a260f7f37b04d3687cd42a3670fa4206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58ed9fdfae12dbd3080432a5355809a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ab58ed9fdfae12dbd3080432a5355809a">read_message_presence_single</a> (<a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml">PresenceSingleData</a> *presence_single)</td></tr>
<tr class="memdesc:ab58ed9fdfae12dbd3080432a5355809a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml" title="Encapsulates and aggregates true presenece data coming from the Xethru X4M300 module. ">PresenceSingleData</a> item from the queue.  <a href="#ab58ed9fdfae12dbd3080432a5355809a">More...</a><br /></td></tr>
<tr class="separator:ab58ed9fdfae12dbd3080432a5355809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd2bcdb413ed51ce524e829fb0f7397"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a1bd2bcdb413ed51ce524e829fb0f7397">peek_message_presence_movinglist</a> ()</td></tr>
<tr class="memdesc:a1bd2bcdb413ed51ce524e829fb0f7397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml" title="Encapsulates and aggregates presence data coming from the Xethru X4M300 module. ">PresenceMovingListData</a> messages available in queue.  <a href="#a1bd2bcdb413ed51ce524e829fb0f7397">More...</a><br /></td></tr>
<tr class="separator:a1bd2bcdb413ed51ce524e829fb0f7397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c9680bf5db65a33e91c20cc57ec84c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a23c9680bf5db65a33e91c20cc57ec84c">read_message_presence_movinglist</a> (<a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml">PresenceMovingListData</a> *presence_moving_list)</td></tr>
<tr class="memdesc:a23c9680bf5db65a33e91c20cc57ec84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml" title="Encapsulates and aggregates presence data coming from the Xethru X4M300 module. ">PresenceMovingListData</a> item from the queue.  <a href="#a23c9680bf5db65a33e91c20cc57ec84c">More...</a><br /></td></tr>
<tr class="separator:a23c9680bf5db65a33e91c20cc57ec84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13235d55707df469bd248e7814b8f591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a13235d55707df469bd248e7814b8f591">peek_message_baseband_ap</a> ()</td></tr>
<tr class="memdesc:a13235d55707df469bd248e7814b8f591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> messages available in queue.  <a href="#a13235d55707df469bd248e7814b8f591">More...</a><br /></td></tr>
<tr class="separator:a13235d55707df469bd248e7814b8f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732ada00cbc25f10cdfad82d55bba31e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a732ada00cbc25f10cdfad82d55bba31e">read_message_baseband_ap</a> (<a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml">BasebandApData</a> *baseband_ap)</td></tr>
<tr class="memdesc:a732ada00cbc25f10cdfad82d55bba31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> item from the queue.  <a href="#a732ada00cbc25f10cdfad82d55bba31e">More...</a><br /></td></tr>
<tr class="separator:a732ada00cbc25f10cdfad82d55bba31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad735a6031441fa4080a39b5240924893"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ad735a6031441fa4080a39b5240924893">peek_message_baseband_iq</a> ()</td></tr>
<tr class="memdesc:ad735a6031441fa4080a39b5240924893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> messages available in queue.  <a href="#ad735a6031441fa4080a39b5240924893">More...</a><br /></td></tr>
<tr class="separator:ad735a6031441fa4080a39b5240924893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b250d4efc01aef19656a0917c92a036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a1b250d4efc01aef19656a0917c92a036">read_message_baseband_iq</a> (<a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml">BasebandIqData</a> *baseband_iq)</td></tr>
<tr class="memdesc:a1b250d4efc01aef19656a0917c92a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> item from the queue.  <a href="#a1b250d4efc01aef19656a0917c92a036">More...</a><br /></td></tr>
<tr class="separator:a1b250d4efc01aef19656a0917c92a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f3684c28c9a54a3a1ab2f741777aae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ac0f3684c28c9a54a3a1ab2f741777aae">peek_message_pulsedoppler_float</a> ()</td></tr>
<tr class="memdesc:ac0f3684c28c9a54a3a1ab2f741777aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of pulse-Doppler float packets available in the queue.  <a href="#ac0f3684c28c9a54a3a1ab2f741777aae">More...</a><br /></td></tr>
<tr class="separator:ac0f3684c28c9a54a3a1ab2f741777aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59d30c6e4ec68384b8cb57c4fefef12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ab59d30c6e4ec68384b8cb57c4fefef12">read_message_pulsedoppler_float</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *data)</td></tr>
<tr class="memdesc:ab59d30c6e4ec68384b8cb57c4fefef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one pulse-Doppler float data message from subscription queue.  <a href="#ab59d30c6e4ec68384b8cb57c4fefef12">More...</a><br /></td></tr>
<tr class="separator:ab59d30c6e4ec68384b8cb57c4fefef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91307a830fde5629cee413451cc78681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a91307a830fde5629cee413451cc78681">peek_message_pulsedoppler_byte</a> ()</td></tr>
<tr class="memdesc:a91307a830fde5629cee413451cc78681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of pulse-Doppler byte packets available in the queue.  <a href="#a91307a830fde5629cee413451cc78681">More...</a><br /></td></tr>
<tr class="separator:a91307a830fde5629cee413451cc78681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b92b973faae9087a17a55768ff4ed6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ac3b92b973faae9087a17a55768ff4ed6">read_message_pulsedoppler_byte</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *data)</td></tr>
<tr class="memdesc:ac3b92b973faae9087a17a55768ff4ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one pulse-Doppler byte data message from subscription queue.  <a href="#ac3b92b973faae9087a17a55768ff4ed6">More...</a><br /></td></tr>
<tr class="separator:ac3b92b973faae9087a17a55768ff4ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb9d536022682a3183852da2b904780"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#acfb9d536022682a3183852da2b904780">peek_message_noisemap_float</a> ()</td></tr>
<tr class="memdesc:acfb9d536022682a3183852da2b904780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of noisemap float packets available in the queue.  <a href="#acfb9d536022682a3183852da2b904780">More...</a><br /></td></tr>
<tr class="separator:acfb9d536022682a3183852da2b904780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0df87f9883a316e96c195b93736578"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a0d0df87f9883a316e96c195b93736578">read_message_noisemap_float</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *data)</td></tr>
<tr class="memdesc:a0d0df87f9883a316e96c195b93736578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one noisemap float data message from subscription queue.  <a href="#a0d0df87f9883a316e96c195b93736578">More...</a><br /></td></tr>
<tr class="separator:a0d0df87f9883a316e96c195b93736578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec1a2b44ba107308899108b85226a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a3dec1a2b44ba107308899108b85226a6">peek_message_noisemap_byte</a> ()</td></tr>
<tr class="memdesc:a3dec1a2b44ba107308899108b85226a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of noisemap byte packets available in the queue.  <a href="#a3dec1a2b44ba107308899108b85226a6">More...</a><br /></td></tr>
<tr class="separator:a3dec1a2b44ba107308899108b85226a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398947acfe42f74483a36889bba99f63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a398947acfe42f74483a36889bba99f63">read_message_noisemap_byte</a> (<a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *data)</td></tr>
<tr class="memdesc:a398947acfe42f74483a36889bba99f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one noisemap byte data message from subscription queue.  <a href="#a398947acfe42f74483a36889bba99f63">More...</a><br /></td></tr>
<tr class="separator:a398947acfe42f74483a36889bba99f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab703588ac37befc0e61ec1053ba019e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ab703588ac37befc0e61ec1053ba019e6">load_noisemap</a> ()</td></tr>
<tr class="memdesc:ab703588ac37befc0e61ec1053ba019e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to load a previously stored noisemap.  <a href="#ab703588ac37befc0e61ec1053ba019e6">More...</a><br /></td></tr>
<tr class="separator:ab703588ac37befc0e61ec1053ba019e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419c335f57d8332d485991d6f1f11824"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a419c335f57d8332d485991d6f1f11824">store_noisemap</a> ()</td></tr>
<tr class="memdesc:a419c335f57d8332d485991d6f1f11824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send command to module to store the current noisemap to module flash.  <a href="#a419c335f57d8332d485991d6f1f11824">More...</a><br /></td></tr>
<tr class="separator:a419c335f57d8332d485991d6f1f11824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac338642be40d8ab80f97c2a1a4a80ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ac338642be40d8ab80f97c2a1a4a80ca3">set_noisemap_control</a> (uint32_t noisemap_control)</td></tr>
<tr class="memdesc:ac338642be40d8ab80f97c2a1a4a80ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the use of noisemap.  <a href="#ac338642be40d8ab80f97c2a1a4a80ca3">More...</a><br /></td></tr>
<tr class="separator:ac338642be40d8ab80f97c2a1a4a80ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3725606679f7a66a534b55e4bca2344e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a3725606679f7a66a534b55e4bca2344e">get_noisemap_control</a> (uint32_t *noisemap_control)</td></tr>
<tr class="memdesc:a3725606679f7a66a534b55e4bca2344e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current noisemap configuration.  <a href="#a3725606679f7a66a534b55e4bca2344e">More...</a><br /></td></tr>
<tr class="separator:a3725606679f7a66a534b55e4bca2344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18d5c416b965898f514a3783bb4ecce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#ae18d5c416b965898f514a3783bb4ecce">get_parameter_file</a> (const std::string &amp;filename, std::string *const data)</td></tr>
<tr class="memdesc:ae18d5c416b965898f514a3783bb4ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the complete parameter file from the module.  <a href="#ae18d5c416b965898f514a3783bb4ecce">More...</a><br /></td></tr>
<tr class="separator:ae18d5c416b965898f514a3783bb4ecce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561daa109ac255652c3453253d7fd37a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a561daa109ac255652c3453253d7fd37a">get_profileid</a> (uint32_t *result)</td></tr>
<tr class="memdesc:a561daa109ac255652c3453253d7fd37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the currently loaded profile.  <a href="#a561daa109ac255652c3453253d7fd37a">More...</a><br /></td></tr>
<tr class="separator:a561daa109ac255652c3453253d7fd37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573a593f7fdbc54471feb4e3a8a39ce5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a573a593f7fdbc54471feb4e3a8a39ce5">set_parameter_file</a> (const std::string *filename, const std::string *data)</td></tr>
<tr class="memdesc:a573a593f7fdbc54471feb4e3a8a39ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a named parameter file on target.  <a href="#a573a593f7fdbc54471feb4e3a8a39ce5">More...</a><br /></td></tr>
<tr class="separator:a573a593f7fdbc54471feb4e3a8a39ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface to the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> Application module. </p>
<p>This interface is used to control the <a class="el" href="namespace_xe_thru.xhtml">XeThru</a> <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module. See the data sheet of the <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module for more information on the <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af2abdd59addf413ce3fdb565a490779a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2abdd59addf413ce3fdb565a490779a">&sect;&nbsp;</a></span>X4M300()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::X4M300::X4M300 </td>
          <td>(</td>
          <td class="paramtype">LockedRadarInterfacePtr &amp;&#160;</td>
          <td class="paramname"><em>radar_interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec679d496f341bafdb5458fde8902e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec679d496f341bafdb5458fde8902e2e">&sect;&nbsp;</a></span>~X4M300()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XeThru::X4M300::~X4M300 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08372898089ecd75af3ee98e9fdc6f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08372898089ecd75af3ee98e9fdc6f55">&sect;&nbsp;</a></span>get_detection_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::get_detection_zone </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual detection zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">start</td><td>start of detection zone in meters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>end of detection zone in meters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a1e97f57cf02e81c406942aedc033e634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e97f57cf02e81c406942aedc033e634">&sect;&nbsp;</a></span>get_detection_zone_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::get_detection_zone_limits </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the potential settings of detection zone from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>smallest value for detection zone start </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>largest value for detection zone end </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>detection zone start and end step size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a3725606679f7a66a534b55e4bca2344e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3725606679f7a66a534b55e4bca2344e">&sect;&nbsp;</a></span>get_noisemap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::get_noisemap_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>noisemap_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current noisemap configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">noisemap_control</td><td>A bitfield of the various features. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ae18d5c416b965898f514a3783bb4ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18d5c416b965898f514a3783bb4ecce">&sect;&nbsp;</a></span>get_parameter_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::get_parameter_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the complete parameter file from the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to a string containing the complete paramter file data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a561daa109ac255652c3453253d7fd37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561daa109ac255652c3453253d7fd37a">&sect;&nbsp;</a></span>get_profileid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::get_profileid </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of the currently loaded profile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to the resulting profile_id. 0 in case of no profile loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a9d48a8a575e606e1396973cdba3aa006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d48a8a575e606e1396973cdba3aa006">&sect;&nbsp;</a></span>get_system_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::get_system_info </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>info_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>system_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing system information given by infocode:<br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info_code</td><td>what information to query. Possible values are?<br />
 XTID_SSIC_ITEMNUMBER -&gt; Returns the product Item Number, including revision. This is programmed in Flash during manufacturing<br />
 XTID_SSIC_ORDERCODE -&gt; Returns the product order code<br />
 XTID_SSIC_FIRMWAREID -&gt; Returns the installed Firmware ID. As viewed from the "highest" level of the software, "X4M300"<br />
 XTID_SSIC_VERSION -&gt; Returns the installed Firmware Version. As viewed from the "highest" level of the software<br />
 XTID_SSIC_BUILD -&gt; Returns information of the SW Build installed on the device<br />
 XTID_SSIC_SERIALNUMBER -&gt; Returns the product serial number<br />
 XTID_SSIC_VERSIONLIST -&gt;Returns ID and version of all components. Calls all components and compound a string E.g. "X4M300:1.0.0.3;XEP:2.3.4.5;X4C51:1.0.0.0;DSP:1.1.1.1" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ab703588ac37befc0e61ec1053ba019e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab703588ac37befc0e61ec1053ba019e6">&sect;&nbsp;</a></span>load_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::load_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to load a previously stored noisemap. </p>
<p>Not yet functional as of FW 1.3</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="aace86c93e998280f19ae64cbd05801d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace86c93e998280f19ae64cbd05801d5">&sect;&nbsp;</a></span>load_profile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::load_profile </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>profileid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the profile given by profileid. </p>
<p>If another profile is already loaded, the other profile is unloaded before the new profile is loaded. The profile does not start, the module remains idle. <br />
 profileid = XTS_ID_APP_PRESENCE_2 (xtid.h) : presence profile</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">profileid</td><td>the id of the profile to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a9fe225acfe8173ac55393401dfccfe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe225acfe8173ac55393401dfccfe2e">&sect;&nbsp;</a></span>module_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::module_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the module. </p>
<p>The client must perform a close and then an open on the <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> to reeastablish connection.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a13235d55707df469bd248e7814b8f591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13235d55707df469bd248e7814b8f591">&sect;&nbsp;</a></span>peek_message_baseband_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_baseband_ap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="ad735a6031441fa4080a39b5240924893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad735a6031441fa4080a39b5240924893">&sect;&nbsp;</a></span>peek_message_baseband_iq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_baseband_iq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="a3dec1a2b44ba107308899108b85226a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec1a2b44ba107308899108b85226a6">&sect;&nbsp;</a></span>peek_message_noisemap_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_noisemap_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of noisemap byte packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="acfb9d536022682a3183852da2b904780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb9d536022682a3183852da2b904780">&sect;&nbsp;</a></span>peek_message_noisemap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_noisemap_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of noisemap float packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a1bd2bcdb413ed51ce524e829fb0f7397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd2bcdb413ed51ce524e829fb0f7397">&sect;&nbsp;</a></span>peek_message_presence_movinglist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_presence_movinglist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml" title="Encapsulates and aggregates presence data coming from the Xethru X4M300 module. ">PresenceMovingListData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in buffer </dd></dl>

</div>
</div>
<a id="a260f7f37b04d3687cd42a3670fa4206b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260f7f37b04d3687cd42a3670fa4206b">&sect;&nbsp;</a></span>peek_message_presence_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_presence_single </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of <a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml" title="Encapsulates and aggregates true presenece data coming from the Xethru X4M300 module. ">PresenceSingleData</a> messages available in queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: size: number of messages in queue </dd></dl>

</div>
</div>
<a id="a91307a830fde5629cee413451cc78681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91307a830fde5629cee413451cc78681">&sect;&nbsp;</a></span>peek_message_pulsedoppler_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_pulsedoppler_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of pulse-Doppler byte packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="ac0f3684c28c9a54a3a1ab2f741777aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f3684c28c9a54a3a1ab2f741777aae">&sect;&nbsp;</a></span>peek_message_pulsedoppler_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::peek_message_pulsedoppler_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of pulse-Doppler float packets available in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>size: number of messages in queue </dd></dl>

</div>
</div>
<a id="ac344832954bf56cbc5420ba08fb0514f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac344832954bf56cbc5420ba08fb0514f">&sect;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::ping </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pong_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure there is a connection to firmware on the Xethru <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pong</td><td>value: 0xaaeeaeea means system ready and 0xaeeaeeaa means system not ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a732ada00cbc25f10cdfad82d55bba31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732ada00cbc25f10cdfad82d55bba31e">&sect;&nbsp;</a></span>read_message_baseband_ap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_baseband_ap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml">BasebandApData</a> *&#160;</td>
          <td class="paramname"><em>baseband_ap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseband_ap</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_baseband_ap_data.xhtml" title="Represents amplitude phase baseband data coming from the module. ">BasebandApData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a1b250d4efc01aef19656a0917c92a036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b250d4efc01aef19656a0917c92a036">&sect;&nbsp;</a></span>read_message_baseband_iq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_baseband_iq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml">BasebandIqData</a> *&#160;</td>
          <td class="paramname"><em>baseband_iq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">baseband_iq</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_baseband_iq_data.xhtml" title="Represents I/Q baseband data coming from the module. ">BasebandIqData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a398947acfe42f74483a36889bba99f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398947acfe42f74483a36889bba99f63">&sect;&nbsp;</a></span>read_message_noisemap_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_noisemap_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one noisemap byte data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting noisemap byte data </dd></dl>

</div>
</div>
<a id="a0d0df87f9883a316e96c195b93736578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0df87f9883a316e96c195b93736578">&sect;&nbsp;</a></span>read_message_noisemap_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_noisemap_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one noisemap float data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting noisemap float data </dd></dl>

</div>
</div>
<a id="a23c9680bf5db65a33e91c20cc57ec84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c9680bf5db65a33e91c20cc57ec84c">&sect;&nbsp;</a></span>read_message_presence_movinglist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_presence_movinglist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml">PresenceMovingListData</a> *&#160;</td>
          <td class="paramname"><em>presence_moving_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml" title="Encapsulates and aggregates presence data coming from the Xethru X4M300 module. ">PresenceMovingListData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">presence_moving_list</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_presence_moving_list_data.xhtml" title="Encapsulates and aggregates presence data coming from the Xethru X4M300 module. ">PresenceMovingListData</a> item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ab58ed9fdfae12dbd3080432a5355809a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58ed9fdfae12dbd3080432a5355809a">&sect;&nbsp;</a></span>read_message_presence_single()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_presence_single </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml">PresenceSingleData</a> *&#160;</td>
          <td class="paramname"><em>presence_single</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml" title="Encapsulates and aggregates true presenece data coming from the Xethru X4M300 module. ">PresenceSingleData</a> item from the queue. </p>
<p>Blocks if queue is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">presence_single</td><td>pointer to returned <a class="el" href="class_xe_thru_1_1_presence_single_data.xhtml" title="Encapsulates and aggregates true presenece data coming from the Xethru X4M300 module. ">PresenceSingleData</a> item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac3b92b973faae9087a17a55768ff4ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b92b973faae9087a17a55768ff4ed6">&sect;&nbsp;</a></span>read_message_pulsedoppler_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_pulsedoppler_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_byte_data.xhtml">PulseDopplerByteData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one pulse-Doppler byte data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting respiration detection listdata </dd></dl>

</div>
</div>
<a id="ab59d30c6e4ec68384b8cb57c4fefef12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59d30c6e4ec68384b8cb57c4fefef12">&sect;&nbsp;</a></span>read_message_pulsedoppler_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::read_message_pulsedoppler_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_xe_thru_1_1_pulse_doppler_float_data.xhtml">PulseDopplerFloatData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one pulse-Doppler float data message from subscription queue. </p>
<dl class="section return"><dt>Returns</dt><dd>: A data object holding the resulting respiration detection listdata </dd></dl>

</div>
</div>
<a id="a6020a93451876f33aa81fe6a38f1d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6020a93451876f33aa81fe6a38f1d078">&sect;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets and restarts the module. </p>
<p>This is a convenience method that calls <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml#a9fe225acfe8173ac55393401dfccfe2e" title="Resets the module. ">module_reset()</a>, disconnects the communication port, and then reestablishes connection with the module using the same port as before.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a3b48c4a8bf8db715de9f72de65520159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b48c4a8bf8db715de9f72de65520159">&sect;&nbsp;</a></span>reset_to_factory_preset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::reset_to_factory_preset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all parameters in the module to factory presets. </p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a2645687c0047f3548f754d2b93e94e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2645687c0047f3548f754d2b93e94e32">&sect;&nbsp;</a></span>set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set baudrate for serial communication during <a class="el" href="class_xe_thru_1_1_module_connector.xhtml" title="This class is responsible for establishing contact with the Xethru module. ">ModuleConnector</a> operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>enum representing the baudrate, XTID_BAUDRATE_XXX in xtid.h. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a87ad0d3a96aa7c2bfb3e30c9b40de3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ad0d3a96aa7c2bfb3e30c9b40de3bb">&sect;&nbsp;</a></span>set_debug_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_debug_level </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets debug level in the Xethru module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>New debug level. Valid range [0-9]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a018a43834fb990f9a6205c69ee095555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018a43834fb990f9a6205c69ee095555">&sect;&nbsp;</a></span>set_detection_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_detection_zone </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current detection zone. </p>
<p>Rules: See <a class="el" href="class_xe_thru_1_1_x4_m300.xhtml" title="Interface to the Xethru X4M300 Application module. ">X4M300</a> datasheet. The actual detection zone is determined by profile configuration. Use the get_detection_zone command to get the actual values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>start of detection zone in meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>end of detection zone in meters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a51ce5eb83d2f4d758a52ed3deae80e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ce5eb83d2f4d758a52ed3deae80e4c">&sect;&nbsp;</a></span>set_led_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_led_control </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command configures the LED mode. </p>
<p><br />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>(modes are defined in xtid.h) <br />
 mode = XTID_LED_MODE_OFF : OFF <br />
 mode = XTID_LED_MODE_SIMPLE : simple <br />
 mode = XTID_LED_MODE_FULL : full (default) <br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intensity</td><td>0 to 100, 0=low, 100=high, not implemented yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="ac338642be40d8ab80f97c2a1a4a80ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac338642be40d8ab80f97c2a1a4a80ca3">&sect;&nbsp;</a></span>set_noisemap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_noisemap_control </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noisemap_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the use of noisemap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noisemap_control</td><td>A bitfield of the various features. <br />
 XTID_NOISEMAP_CONTROL_ENABLE -&gt; Bit 0, turn on use of noisemap.<br />
 XTID_NOISEMAP_CONTROL_ADAPTIVE -&gt; Bit 1, adapt noisemap over time.<br />
 XTID_NOISEMAP_CONTROL_INIT_ON_RESET -&gt; Bit 2, don't store but initialize the noisemap every time. Bit 2 unset means load the stored noisemap if present, and initialize and store it if not present.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a62e832113822e712facfb6a9bd9c9482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e832113822e712facfb6a9bd9c9482">&sect;&nbsp;</a></span>set_output_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_output_control </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>output_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control module profile output. </p>
<p>Enable and disable data messages. Several calls can be made, one for each available output message the profile provides.</p>
<p>Only one of XTS_ID_BASEBAND_IQ and XTS_ID_BASEBAND_AMPLITUDE_PHASE can be enabled at a time. Enabling one disables the other. Disabling one, even if it is already disabled, disables the other.</p>
<p>Only one of XTS_ID_PULSEDOPPLER_FLOAT and XTS_ID_PULSEDOPPLER_BYTE can be enabled for each of XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE and XTID_OUTPUT_CONTROL_PD_FAST_ENABLE. Same with XTS_ID_NOISEMAP_FLOAT and XTS_ID_NOISEMAP_BYTE. Turning on a float output automatically disables the byte output, and vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output_feature</td><td>see values in xtid.h.<br />
 Possible features are:<br />
 XTS_ID_PRESENCE_SINGLE<br />
 XTS_ID_PRESENCE_MOVINGLIST<br />
 XTS_ID_BASEBAND_IQ<br />
 XTS_ID_BASEBAND_AMPLITUDE_PHASE<br />
 XTS_ID_PULSEDOPPLER_FLOAT<br />
 XTS_ID_PULSEDOPPLER_BYTE<br />
 XTS_ID_NOISEMAP_FLOAT<br />
 XTS_ID_NOISEMAP_BYTE<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_control</td><td>see values in xtid.h<br />
 Typical values:<br />
 XTID_OUTPUT_CONTROL_DISABLE = disable<br />
 XTID_OUTPUT_CONTROL_ENABLE = enable<br />
 <br />
 For pulse-Doppler and noisemap byte/float:<br />
 XTID_OUTPUT_CONTROL_PD_SLOW_ENABLE<br />
 XTID_OUTPUT_CONTROL_PD_FAST_ENABLE<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a573a593f7fdbc54471feb4e3a8a39ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573a593f7fdbc54471feb4e3a8a39ce5">&sect;&nbsp;</a></span>set_parameter_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_parameter_file </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a named parameter file on target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name to call the parameter file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The content of the parameter-file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a2ab6f73f1e935aee36eda94c46972d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab6f73f1e935aee36eda94c46972d37">&sect;&nbsp;</a></span>set_sensitivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_sensitivity </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sensitivity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the overall sensitivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sensitivity</td><td>: 0 to 9, 0 = low, 9 = high </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a566ab01887a1144ffc88b47d344bbbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566ab01887a1144ffc88b47d344bbbf5">&sect;&nbsp;</a></span>set_sensor_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::set_sensor_mode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the execution mode of the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>see xtid.h for profileid values.<br />
 XTID_SM_RUN : Start profile execution<br />
 XTID_SM_IDLE : Halts profile execution. Can be resumed by setting mode to Run.<br />
 XTID_SM_STOP : Stops profile execution. Must do load_profile to continue.<br />
 XTID_SM_MANUAL : Routes X4 radar data directly to host rather than to profile execution. Can then interact directly with <a class="el" href="class_xe_thru_1_1_x_e_p.xhtml" title="XEP class gives access to XEP functionality on target via module connector. ">XEP</a> / X4Driver. Will disrupt profile performance.<br />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Not used, ignored, can be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="af92d0ed6b1e9227a30091554859dd8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92d0ed6b1e9227a30091554859dd8fa">&sect;&nbsp;</a></span>start_bootloader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::start_bootloader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters the bootloader for FW upgrades. </p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a419c335f57d8332d485991d6f1f11824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419c335f57d8332d485991d6f1f11824">&sect;&nbsp;</a></span>store_noisemap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::store_noisemap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send command to module to store the current noisemap to module flash. </p>
<p>Fails if a store already is active, for example during the first initialize with XTID_NOISEMAP_CONTROL_INIT_ON_RESET disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<a id="a467f849f6541ec51720e35e944d255ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467f849f6541ec51720e35e944d255ae">&sect;&nbsp;</a></span>system_run_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XeThru::X4M300::system_run_test </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>testcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the different manufacturing tests identified by testcode. </p>
<p>Can return any number of results depending on test_mode. Host must know how to parse test results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">testcode</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>data buffer containing the result from a test run. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status : success in case of 0 / failure in any other case </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_x4_m300_8hpp_source.xhtml">X4M300.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/>
 <address class="footer">
 Copyright &copy; 2016 Novelda AS - <a href="http://www.xethru.com">www.xehtru.com</a><br />
 <small>
  Generated by &#160;<a href="http://www.doxygen.org/index.html">
  <img class="footer" src="doxygen.png" alt="doxygen"/>
  </a> 1.8.12
 </small>
 </address>
</body>
</html>
